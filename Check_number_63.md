# Check_number_63

## Information
**Category** | **Points** 
--- | --- 
 Crypto | 150 

## Description

I know the "common modulus attack" on RSA. But as far as I know, the attacker can NOT factor n, right? I generated 63 keys with different public exponents. I also generated the check numbers to confirm the keys were valid. Sadly, public exponents and check numbers were leaked. Am I still safe?

## Solution

We have to factor $n$ given multiple primes $e_i$, and $\frac{e_i*d_i-1}{\phi(n)}$, where $d_i$ is the inverse of $e_i$ mod $\phi(n)$.

Since $\phi(n)=pq-(p+q)+1$ and $e_i*d_i-1=k\phi(n)$ (k is integer), we rewrite to get multiple modular equations $p+q=pq+k^{-1}+1=n+k^{-1}+1$ mod $e_i$. Apply CRT, we can get $p+q$ mod  $\prod e_i$

However, $p+q$ is about 1024 bits, $\prod e_i$ is about 1008 bits, so we will have to brute a little bit to get the exact $p+q$.

Finally, given $p+q$ and $n=pq$, we can easily find $p$ and $q$ and apply the script given to get the flag.

```python
from Crypto.Util.number import *
import gmpy2
from hashlib import *

r=24575303335152579483219397187273958691356380033536698304119157688003502052393867359624475789987237581184979869428436419625817866822376950791646781307952833871208386360334267547053595730896752931770589720203939060500637555186552912818531990295111060561661560818752278790449531513480358200255943011170338510477311001482737373145408969276262009856332084706260368649633253942184185551079729283490321670915209284267457445004967752486031694845276754057130676437920418693027165980362069983978396995830448343187134852971000315053125678630516116662920249232640518175555970306086459229479906220214332209106520050557209988693711
a=[(65537,36212),(65539,5418),(65543,27200),(65551,37275),(65557,19020),(65563,18986),(65579,30121),(65581,55506),(65587,34241),(65599,35120),(65609,49479),(65617,38310),(65629,65504),(65633,15629),(65647,27879),(65651,6535),(65657,24690),(65677,57656),(65687,58616),(65699,19857),(65701,9326),(65707,8739),(65713,60630),(65717,35109),(65719,47240),(65729,12246),(65731,35776),(65761,23462),(65777,48929),(65789,13100),(65809,10941),(65827,55227),(65831,21264),(65837,36029),(65839,1057),(65843,11772),(65851,30488),(65867,45637),(65881,40155),(65899,42192),(65921,64114),(65927,8091),(65929,5184),(65951,8153),(65957,33274),(65963,17143),(65981,7585),(65983,62304),(65993,58644),(66029,15067),(66037,47377),(66041,35110),(66047,30712),(66067,4519),(66071,53528),(66083,1925),(66089,29064),(66103,32308),(66107,52310),(66109,13040),(66137,27981),(66161,36954),(66169,9902)]
s=1

for i in a:
    s*=i[0]
m=[i[0] for i in a]
n=[int((inverse(i[1],i[0])+1+r)%i[0]) for i in a]
sum=int(CRT_list(n,m))

while True:
    if sum^2 - 4*r <=0:
        sum+=s
        continue
    elif gmpy2.iroot(sum^2-4*r,int(2))[1] == True:
        break
    else:
        sum+=s

x=var('x')
q=x^2-sum*x+r
print(solve(q,x))

p=143026116177515987828041940647526671395967499944486647122671304348705870893095386822209597313090170117018866207825081216305902261238513999958328503013758234695405284984667174362118290023851621106497360421553676680838786617409394739766549865486382387391080554313144716298920178020814779020633607861091589038459
q=r//p
if p > q:p,q = q,p
flag = "ACSC{" + sha512( f"{p}{q}".encode() ).hexdigest() + "}"
print(flag)
```

> Flag is: ACSC{02955bb28b6be53c08912dbf05a4081b763e69a191b39e632341a0cd37120ba3668c3f1e97815259dc46f0665b0713062d159cc85c47df77468819d367d25746}
